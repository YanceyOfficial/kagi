import { apiError, requireSession, withAuth } from '@/lib/api-helpers'
import { db } from '@/lib/db'
import { keyCategories, keyEntries } from '@/lib/db/schema'
import { decrypt, decryptJson } from '@/lib/encryption'
import { openai } from '@ai-sdk/openai'
import { generateObject } from 'ai'
import { eq } from 'drizzle-orm'
import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'

const requestSchema = z.object({
  prompt: z.string().min(1).max(2000)
})

// The AI returns an array of selected key references (no actual values)
const aiResponseSchema = z.object({
  selectedKeys: z.array(
    z.object({
      entryId: z.string().uuid(),
      // The AI may rename the env var (e.g. GA_KEY → NEXT_PUBLIC_GA_KEY)
      envVarName: z.string().min(1),
      reason: z.string()
    })
  )
})

export async function POST(request: NextRequest) {
  return withAuth(async () => {
    const session = await requireSession('ai:extract')
    const body = await request.json()
    const parsed = requestSchema.safeParse(body)

    if (!parsed.success) return apiError(parsed.error.message)

    const { prompt } = parsed.data

    // Fetch all categories + entries for this user (names only — no values)
    const allCategories = await db
      .select()
      .from(keyCategories)
      .where(eq(keyCategories.userId, session.user.id))

    const allEntries = await db
      .select({
        id: keyEntries.id,
        categoryId: keyEntries.categoryId,
        projectName: keyEntries.projectName,
        environment: keyEntries.environment
      })
      .from(keyEntries)
      .innerJoin(keyCategories, eq(keyEntries.categoryId, keyCategories.id))
      .where(eq(keyCategories.userId, session.user.id))

    // Build a structured context for the AI (key names only, never values)
    const keyContext = allCategories.map((cat) => ({
      categoryId: cat.id,
      categoryName: cat.name,
      keyType: cat.keyType,
      envVarName: cat.envVarName,
      fieldDefinitions: cat.fieldDefinitions,
      entries: allEntries
        .filter((e) => e.categoryId === cat.id)
        .map((e) => ({
          entryId: e.id,
          projectName: e.projectName,
          environment: e.environment
        }))
    }))

    const systemPrompt = `You are a key management assistant for the Kagi application.
Your job is to analyze a user's request and select the appropriate private keys from their key vault.

IMPORTANT RULES:
- You will ONLY see key names and project names — never actual secret values
- Select only the keys that match the user's request
- Consider the context carefully: if the user mentions a frontend/Next.js project,
  rename GA/analytics keys with NEXT_PUBLIC_ prefix
- If the user specifies a project name (e.g., "Blog"), prefer entries with that projectName
- If no project is specified, select entries that seem most relevant
- Return the entryId from the provided key context
- Provide a brief reason for each selection

Available keys in the vault:
${JSON.stringify(keyContext, null, 2)}`

    const { object } = await generateObject({
      model: openai('gpt-4o-mini'),
      schema: aiResponseSchema,
      system: systemPrompt,
      prompt
    })

    // Build valid entry ID set to prevent injection attacks
    const validEntryIds = new Set(allEntries.map((e) => e.id))

    const selected = object.selectedKeys.filter((k) =>
      validEntryIds.has(k.entryId)
    )

    if (selected.length === 0) {
      return NextResponse.json({
        data: {
          selectedKeys: [],
          envContent: '# No matching keys found'
        }
      })
    }

    // Fetch and decrypt the selected entries to build the .env file
    const entryRows = await db
      .select({ entry: keyEntries, category: keyCategories })
      .from(keyEntries)
      .innerJoin(keyCategories, eq(keyEntries.categoryId, keyCategories.id))
      .where(eq(keyCategories.userId, session.user.id))

    const envLines: string[] = [
      '# Generated by Kagi AI Key Extractor',
      `# Prompt: ${prompt}`,
      ''
    ]

    for (const selectedKey of selected) {
      const row = entryRows.find((r) => r.entry.id === selectedKey.entryId)
      if (!row) continue

      const { entry, category } = row

      if (category.keyType === 'group') {
        const values = decryptJson<Record<string, string>>(entry.encryptedValue)
        const fields = category.fieldDefinitions ?? Object.keys(values)

        envLines.push(`# ${category.name} — ${entry.projectName}`)
        for (const field of fields) {
          if (values[field] !== undefined) {
            envLines.push(`${field}="${values[field]}"`)
          }
        }
        envLines.push('')
      } else {
        const value = decrypt(entry.encryptedValue)
        const comment = `# ${category.name} — ${entry.projectName}${selectedKey.reason ? ` (${selectedKey.reason})` : ''}`
        envLines.push(comment)
        envLines.push(`${selectedKey.envVarName}="${value}"`)
        envLines.push('')
      }
    }

    return NextResponse.json({
      data: {
        selectedKeys: selected,
        envContent: envLines.join('\n')
      }
    })
  })
}
